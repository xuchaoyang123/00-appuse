<!--
 * @Author: your name
 * @Date: 2021-05-09 21:29:49
 * @LastEditTime: 2021-05-29 11:56:38
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /01-good/use/08. Kubernetes/003.kubeadm方式部署k8s.md
-->

> ## 二进制包方式安装 k8s

#

### 1.平台规划

|    角色    |       ip       |                            组件                            |
| :--------: | :------------: | :--------------------------------------------------------: |
| k8s-master | 192.168.44.147 | kube-apiserver,kube-controller-manager,kube-scheduler,etcd |
| k8s-node1  | 192.168.44.148 |               kubelet,kube-proxy,docker,etcd               |

#

### 2.服务器初始化

```bash


#1.[所有节点] 关闭防火墙
	systemctl stop firewalld
	systemctl disable firewalld


#2.[所有节点] 关闭seliunx
	sed -i 's/enforcing/disabled/' /etc/seliunx/config #永久
	setenforce 0 #临时


#3.[所有节点] 关闭swap
	swapoff -a  #临时
	sed -ri 's/.*swap.*/#&/' /etc/fstab #永久


#4.[所有节点] 根据规划设置主机名
	hostnamectl set-hostname master
	hostnamectl set-hostname node1
	hostnamectl set-hostname node2


#5.[master节点] 在master添加hosts
	cat >> /etc/hosts <<EOF
	192.168.44.147 m1
	192.168.44.148 n1
	EOF


#6.[所有节点] 将桥接的ipv4流量传递到iptables的链
	cat > /etc/sysctl.d/k8s.conf <<EOF
	net.bridge.bridge-nf-call-ip6tables=1
	net.bridge.bridge-nf-call-iptables=1
	EOF
	sysctl --system  #生效



#7.[所有节点] 时间同步
	yum install ntpdate -y
	ntpdate time.windos.com



#8.[所有节点]配置阿里云yum源

        cat <<EOF > kubernetes.repo
        [kubernetes]
        name=Kubernetes
        baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
        enabled=1
        gpgcheck=1
        repo_gpgcheck=1
        gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
        EOF

```

### 3.创建 cfssl 证书

```bash


    #1.[master节点] 准备 cfssl 证书生成工具
    wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
    wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
    wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
    chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64
    mv cfssl_linux-amd64 /usr/local/bin/cfssl
    mv cfssljson_linux-amd64 /usr/local/bin/cfssljson
    mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo



    #2.[master节点] 生成 Etcd 证书
      #自签证书颁发机构（CA）
      #创建工作目录：
      mkdir -p ~/TLS/{etcd,k8s}
      cd TLS/etcd



    #3. [master节点] 自签 CA：
        cat > ca-config.json<< EOF { "signing": { "default": { "expiry": "87600h" },"profiles": { "www": { "expiry": "87600h", "usages": [ "signing","key encipherment", "server auth", "client auth" ] } } } }EOF

        cat > ca-csr.json<< EOF { "CN": "etcd CA", "key": { "algo": "rsa", "size": 2048 },"names": [ { "C": "CN", "L": "Beijing", "ST": "Beijing" } ] }EOF



    #4. [master节点] 生成证书
         cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
         #ls *pem
         #ca-key.pem ca.pem



    #5.[master节点] 使用自签 CA 签发 Etcd HTTPS 证书
        #创建证书申请文件：
        #注：上述文件 hosts 字段中 IP 为所有 etcd 节点的集群内部通信 IP，一个都不能少！为了 方便后期扩容可以多写几个预留的 IP。
        cat > server-csr.json<< EOF { "CN": "etcd", "hosts": [ "192.168.44.147", "192.168.44.148"],"key": { "algo": "rsa", "size": 2048 },"names": [ { "C": "CN", "L": "BeiJing", "ST": "BeiJing" } ] }EOF



    #6.[master节点] 生成证书
     cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json - profile=www server-csr.json | cfssljson -bare server
     #ls server*pem
     #server-key.pem server.pem


```

### 4.部署 etcd 集群

```bash

    #1.[所有节点] 从 Github 下载二进制文件
        下载地址：https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz


    #2.[所有节点] 部署 Etcd 集群
      #创建工作目录并解压二进制包
      $mkdir /opt/etcd/{bin,cfg,ssl} –p
      $ tar zxvf etcd-v3.4.9-linux-amd64.tar.gz
      $mv etcd-v3.4.9-linux-amd64/{etcd,etcdctl} /opt/etcd/bin/



    #3.[所有节点] 创建 etcd 配置文件

        cat > /opt/etcd/cfg/etcd.conf << EOF
        #[Member]
        ETCD_NAME="etcd-n"                                                  # 修改此处，节点 2 改为 etcd-2，节点 3 改为 etcd-3
        ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
        ETCD_LISTEN_PEER_URLS="https://192.168.44.147:2380"                  # 修改此处为当前服务器 IP
        ETCD_LISTEN_CLIENT_URLS="https://192.168.44.147:2379"                # 修改此处为当前服务器 IP
        #[Clustering]
        ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.44.147:2380"       # 修改此处为当前 服务器 IP ETCD_ADVERTISE_CLIENT_URLS="https://192.168.44.147:2379"             # 修改此处为当前服务器 IPETCD_INITIAL_CLUSTER="etcd-1=https://192.168.44.147:2380,etcd-2=https://192.168.44.148:2380"
        ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
        ETCD_INITIAL_CLUSTER_STATE="new"

        #参数含义
        ETCD_NAME：节点名称，集群中唯一
        ETCD_DATA_DIR：数据目录
        ETCD_LISTEN_PEER_URLS：集群通信监听地址
        ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址
        ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址
        ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址
        ETCD_INITIAL_CLUSTER：集群节点地址
        ETCD_INITIAL_CLUSTER_TOKEN：集群 Token
        ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new 是新集群，existing 表示加入 已有集群



    #4.systemd 管理 etcd
        cat > /usr/lib/systemd/system/etcd.service << EOF
        [Unit]
        Description=Etcd Server
        After=network.target
        After=network-online.target
        Wants=network-online.target
        [Service]
        Type=notify
        EnvironmentFile=/opt/etcd/cfg/etcd.conf
        ExecStart=/opt/etcd/bin/etcd \
        --cert-file=/opt/etcd/ssl/server.pem \
        --key-file=/opt/etcd/ssl/server-key.pem \
        --peer-cert-file=/opt/etcd/ssl/server.pem \
        --peer-key-file=/opt/etcd/ssl/server-key.pem \
        --trusted-ca-file=/opt/etcd/ssl/ca.pem \
        --peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \
        --logger=zap
        Restart=on-failure
        LimitNOFILE=65536
        [Install]
        WantedBy=multi-user.target
        EOF


    #5.拷贝刚才生成的证书
        #把刚才生成的证书拷贝到配置文件中的路径
        cp ~/TLS/etcd/ca*pem ~/TLS/etcd/server*pem /opt/etcd/ssl/



    #6.启动并设置开机启动
        systemctl daemon-reload
        systemctl start etcd
        systemctl enable etcd


    #7.查看集群状态
    $ETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem -- cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem -- endpoints="https://192.168.44.147:2379,https://192.168.44.148:2379 endpoint health
    #https://192.168.44.147:2379 is healthy: successfully committed proposal: took = 8.154404ms
    #https://192.168.44.148:2379 is healthy: successfully committed proposal: took = 9.044117ms
    #如果输出上面信息，就说明集群部署成功。如果有问题第一步先看日志： /var/log/message 或 journalctl -u etcd
```

### 5.安装 docker

```bash
    #kubernetes默认CRI(容器运行时)为docker,因此先安装docker.

    #1.[所有节点] yum配置
            yum-config-manager \
            --add-repo \
            https://download.docker.com/linux/centos/docker-ce.repo


    #2.[所有节点] 安装
            yum install docker-ce docker-ce-cli containerd.io -y               安装docker ce 社区版



    #3.[所有节点] 配置国内镜像加速
            sudo mkdir -p /etc/docker                                           #更换国内镜像站
            sudo tee /etc/docker/daemon.json <<-'EOF'
            {
            "registry-mirrors": ["https://slfru11m.mirror.aliyuncs.com"]
            }
            EOF


    #4.[所有节点] 启动服务
            sudo systemctl daemon-reload
            sudo systemctl restart docker


    #5.[所有节点] 测试
            docker  info                                                        #详细的信息 包括镜像和容器个数


```

### 6.部署 Master Node

```bash
    #1.[master节点] 生成 kube-apiserver 证书
    #自签证书颁发机构（CA）
        cat > ca-config.json<< EOF { "signing": { "default": { "expiry": "87600h" },"profiles": { "kubernetes":{ "expiry": "87600h", "usages": [ "signing", "key encipherment", "server auth", "client auth" ] } }
} }EOF cat > ca-csr.json<< EOF { "CN": "kubernetes", "key": { "algo": "rsa", "size": 2048 },"names": [ { "C": "CN", "L": "Beijing", "ST": "Beijing", "O": "k8s", "OU": "System" } ] }EOF



    #2.[master节点] 生成证书
        $cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
        #ls *pem
        #ca-key.pem ca.pem


    #3.[master节点] 使用自签 CA 签发 kube-apiserver HTTPS 证书
        #创建证书申请文件
        cd TLS/k8s cat > server-csr.json<< EOF { "CN": "kubernetes", "hosts": [ "10.0.0.1", "127.0.0.1", "192.168.44.147", "192.168.44.148", "kubernetes", "kubernetes.default", "kubernetes.default.svc", "kubernetes.default.svc.cluster", "kubernetes.default.svc.cluster.local" ],"key": { "algo": "rsa", "size": 2048 },"names": [ { "C": "CN", "L": "BeiJing", "ST": "BeiJing",
"O": "k8s", "OU": "System" } ] }EOF



    #4.[master节点] 生成证书
        $cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json - profile=kubernetes server-csr.json | cfssljson -bare server
        #ls server*pem
        #server-key.pem server.pem


    #5.[master节点] 解压二进制包
        #下载地址： https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG- 1.18.md#v1183
        #注：打开链接你会发现里面有很多包，下载一个 server 包就够了，包含了 Master 和 Worker Node 二进制文件。

        mkdir -p /opt/kubernetes/{bin,cfg,ssl,logs}
        tar zxvf kubernetes-server-linux-amd64.tar.gz
        cd kubernetes/server/bin
        cp kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bin
        cp kubectl /usr/bin/




    #6.[master节点] 部署 kube-apiserver创建配置文件
        cat > /opt/kubernetes/cfg/kube-apiserver.conf << EOF
        KUBE_APISERVER_OPTS="--logtostderr=false \\
        --v=2 \\
        --log-dir=/opt/kubernetes/logs \\
        --etcd- servers=https://192.168.31.71:2379,https://192.168.31.72:2379,https://192.168.3 1.73:2379 \\ --bind-address=192.168.31.71 \\
        --secure-port=6443 \\
        --advertise-address=192.168.31.71 \\
        --allow-privileged=true \\
        --service-cluster-ip-range=10.0.0.0/24 \\
        --enable-admission- plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestric tion \\
        --authorization-mode=RBAC,Node \\
        --enable-bootstrap-token-auth=true \\
        --token-auth-file=/opt/kubernetes/cfg/token.csv \\
        --service-node-port-range=30000-32767 \\
        --kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \\
        --kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \\
        --tls-cert-file=/opt/kubernetes/ssl/server.pem \\
        --tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \\
        --client-ca-file=/opt/kubernetes/ssl/ca.pem \\
        --service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \\
        --etcd-cafile=/opt/etcd/ssl/ca.pem \\
        --etcd-certfile=/opt/etcd/ssl/server.pem \\
        --etcd-keyfile=/opt/etcd/ssl/server-key.pem \\
        --audit-log-maxage=30 \\
        --audit-log-maxbackup=3 \\
        --audit-log-maxsize=100 \\
        --audit-log-path=/opt/kubernetes/logs/k8s-audit.log"
        EOF


        #参数含义
        注：上面两个\ \ 第一个是转义符，第二个是换行符，使用转义符是为了使用 EOF 保留换 行符。
         –logtostderr：启用日志
         —v：日志等级
         –log-dir：日志目录
         –etcd-servers：etcd 集群地址
         –bind-address：监听地址
         –secure-port：https 安全端口
         –advertise-address：集群通告地址
         –allow-privileged：启用授权
         –service-cluster-ip-range：Service 虚拟 IP 地址段
         –enable-admission-plugins：准入控制模块
         –authorization-mode：认证授权，启用 RBAC 授权和节点自管理
         –enable-bootstrap-token-auth：启用 TLS bootstrap 机制
         –token-auth-file：bootstrap token 文件
         –service-node-port-range：Service nodeport 类型默认分配端口范围
         –kubelet-client-xxx：apiserver 访问 kubelet 客户端证书
         –tls-xxx-file：apiserver https 证书
         –etcd-xxxfile：连接 Etcd 集群证书
         –audit-log-xxx：审计日志



    #7.[master节点] 拷贝刚才生成的证书
        #把刚才生成的证书拷贝到配置文件中的路径
        cp ~/TLS/k8s/ca*pem ~/TLS/k8s/server*pem /opt/kubernetes/ssl/



    #8.[master节点] 启用 TLS Bootstrapping 机制
        #proxy 要与 kube-apiserver 进行通信，必须使用 CA 签发的有效证书才可以，当 Node 节点很多时，这种客户端证书颁发需要大量工作，同样也会增加集群扩展复杂度。为了 简化流程，Kubernetes 引入了 TLS bootstraping 机制来自动颁发客户端证书，kubelet 会以一个低权限用户自动向 apiserver 申请证书，kubelet 的证书由 apiserver 动态签署。
        #所以强烈建议在 Node 上使用这种方式，目前主要用于 kubelet，kube-proxy 还是由我 们统一颁发一个证书。

        #创建上述配置文件中 token 文件：
        cat > /opt/kubernetes/cfg/token.csv << EOF c47ffb939f5ca36231d9e3121a252940,kubelet-bootstrap,10001,"system:node- bootstrapper" EOF

        #格式：token，用户名，UID，用户组 token 也可自行生成替换
        head -c 16 /dev/urandom | od -An -t x | tr -d ' '



    #9.[master节点] systemd 管理 apiserver
        cat > /usr/lib/systemd/system/kube-apiserver.service << EOF
        [Unit]
        Description=Kubernetes API Server
        Documentation=https://github.com/kubernetes/kubernetes
        [Service]
        EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf
        ExecStart=/opt/kubernetes/bin/kube-apiserver \
        $KUBE_APISERVER_OPTS Restart=on-failure
        [Install]
        WantedBy=multi-user.target
        EOF



    #10.[master节点] 启动并设置开机启动
        systemctl daemon-reload systemctl
        start kube-apiserver
        systemctl enable kube-apiserver



    #11.[master节点] 授权 kubelet-bootstrap 用户允许请求证书
    kubectl create clusterrolebinding kubelet-bootstrap \
    --clusterrole=system:node-bootstrapper \
    --user=kubelet-bootstrap


    #12.[master节点] 部署 kube-controller-manager创建配置文件
        cat > /opt/kubernetes/cfg/kube-controller-manager.conf << EOF KUBE_CONTROLLER_MANAGER_OPTS="--logtostderr=false \\
        --v=2 \\
        --log-dir=/opt/kubernetes/logs \\
        --leader-elect=true \\
        --master=127.0.0.1:8080 \\
        --bind-address=127.0.0.1 \\
        --allocate-node-cidrs=true \\
        --cluster-cidr=10.244.0.0/16 \\
        --service-cluster-ip-range=10.0.0.0/24 \\
        --cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \\
        --cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem \\
        --root-ca-file=/opt/kubernetes/ssl/ca.pem \\
        --service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \\ --experimental-cluster-signing-duration=87600h0m0s"
        EOF

        #–master：通过本地非安全本地端口 8080 连接 apiserver
        #–leader-elect：当该组件启动多个时，自动选举（HA）
        #–cluster-signing-cert-file/–cluster-signing-key-file：自动为 kubelet 颁发证书 的 CA，与 apiserver 保持一致




    #13.[master节点] systemd 管理 controller-manager
        cat > /usr/lib/systemd/system/kube-controller-manager.service << EOF
        [Unit]
        Description=Kubernetes Controller Manager
        Documentation=https://github.com/kubernetes/kubernetes
        [Service]
        EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf
        ExecStart=/opt/kubernetes/bin/kube-controller-manager\
        $KUBE_CONTROLLER_MANAGER_OPTS
        Restart=on-failure
        [Install]
        WantedBy=multi-user.target
        EOF



    #14.[master节点] 启动并设置开机启动
        systemctl daemon-reload
        systemctl start kube-controller-manager
        systemctl enable kube-controller-manager



    #15.[master节点] 部署kube-scheduler创建配置文件
        cat > /opt/kubernetes/cfg/kube-scheduler.conf << EOF
        KUBE_SCHEDULER_OPTS="--logtostderr=false \
        --v=2 \
        --log-dir=/opt/kubernetes/logs \
        --leader-elect \
        --master=127.0.0.1:8080 \
        --bind-address=127.0.0.1"
         EOF

         #–master：通过本地非安全本地端口 8080 连接 apiserver
         #–leader-elect：当该组件启动多个时，自动选举（HA）



    #16.[master节点] systemd 管理 scheduler
        cat > /usr/lib/systemd/system/kube-scheduler.service << EOF
        [Unit]
        Description=Kubernetes Scheduler
        Documentation=https://github.com/kubernetes/kubernetes
        [Service]
        EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf
        ExecStart=/opt/kubernetes/bin/kube-scheduler \
        $KUBE_SCHEDULER_OPTS Restart=on-failure
        [Install]
        WantedBy=multi-user.target
        EOF



    #17.[master节点] 启动并设置开机启动
        systemctl daemon-reload
        systemctl start kube-scheduler
        systemctl enable kube-scheduler


    #18.[master节点] 查看集群状态
         kubectl get cs
         NAME STATUS MESSAGE ERROR
         scheduler Healthy ok controller-manager Healthy ok
         etcd-2 Healthy {"health":"true"}
         etcd-1 Healthy {"health":"true"}
         etcd-0 Healthy {"health":"true"}
         #如上输出说明 Master 节点组件运行正常。

```

### 7.部署 Worker Node

```bash
    #下面还是在 Master Node 上操作，即同时作为 Worker Node
    #1.创建工作目录并拷贝二进制文件 在所有 worker node 创建工作目录
     mkdir -p /opt/kubernetes/{bin,cfg,ssl,logs}


     #2.从 master 节点拷贝：
        cd kubernetes/server/bin
        cp kubelet kube-proxy /opt/kubernetes/bin # 本地拷贝


    #3.部署 kubelet创建配置文件
        cat > /opt/kubernetes/cfg/kubelet.conf << EOF
        KUBELET_OPTS="--logtostderr=false \\
        --v=2 \\
        --log-dir=/opt/kubernetes/logs \\
        --hostname-override=k8s-master \\
        --network-plugin=cni \\
        --kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\
        --bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\
        --config=/opt/kubernetes/cfg/kubelet-config.yml \\
        --cert-dir=/opt/kubernetes/ssl \\
        --pod-infra-container-image=lizhenliang/pause-amd64:3.0"
        EOF

        #参数含义
        –hostname-override：显示名称,集群中唯一
        –network-plugin：启用 CNI
        –kubeconfig：空路径，会自动生成，后面用于连接 apiserver
        –bootstrap-kubeconfig：首次启动向 apiserver 申请证书
        –config：配置参数文件
        –cert-dir：kubelet 证书生成目录
        –pod-infra-container-image：管理 Pod 网络容器的镜像



    #4.配置参数文件
        cat > /opt/kubernetes/cfg/kubelet-config.yml << EOF
        kind: KubeletConfiguration
        apiVersion: kubelet.config.k8s.io/v1beta1
        address: 0.0.0.0
        port: 10250
        readOnlyPort: 10255
        cgroupDriver: cgroupfs
        clusterDNS:
        - 10.0.0.2
        clusterDomain: cluster.local
        failSwapOn: false
        authentication:
           anonymous:
              enabled: false
           webhook:
              cacheTTL: 2m0s
              enabled: true
           x509:
              clientCAFile: /opt/kubernetes/ssl/ca.pem
           authorization:
              mode: Webhook
              webhook:
                 cacheAuthorizedTTL: 5m0s
                 cacheUnauthorizedTTL: 30s
                 evictionHard:
                    imagefs.available: 15%
                    memory.available: 100Mi
                    nodefs.available: 10%
                    nodefs.inodesFree: 5%
                    maxOpenFiles: 1000000
                    maxPods: 110
                    EOF


        #5.生成 bootstrap.kubeconfig 文件
        KUBE_APISERVER="https://192.168.31.71:6443" # apiserver IP:PORT
        TOKEN="c47ffb939f5ca36231d9e3121a252940" # 与 token.csv 里保持一致


        #6.生成 kubelet bootstrap kubeconfig 配置文件
            $kubectl config set-cluster kubernetes \
            --certificate-authority=/opt/kubernetes/ssl/ca.pem \
            --embed-certs=true \
            --server=${KUBE_APISERVER} \
            --kubeconfig=bootstrap.kubeconfig

            $kubectl config set-credentials "kubelet-bootstrap" \
            --token=${TOKEN} \
            --kubeconfig=bootstrap.kubeconfig kubectl config set-context default \
            --cluster=kubernetes \
            --user="kubelet-bootstrap" \
            --kubeconfig=bootstrap.kubeconfig

            $kubectl config use-context default --kubeconfig=bootstrap.kubeconfig


      #7.拷贝到配置文件路径
        cp bootstrap.kubeconfig /opt/kubernetes/cfg



        #8.systemd 管理 kubelet
        cat > /usr/lib/systemd/system/kubelet.service << EOF
        [Unit]
        Description=Kubernetes Kubelet After=docker.service
        [Service]
        EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf
        ExecStart=/opt/kubernetes/bin/kubelet \$KUBELET_OPTS
        Restart=on-failure
        LimitNOFILE=65536
        [Install]
        WantedBy=multi-user.target
        EOF


        #9.启动并设置开机启动
        systemctl daemon-reload
        systemctl start kubelet
        systemctl enable kubelet


        #10.批准 kubelet 证书申请并加入集群
            # 查看 kubelet 证书请求
            $kubectl get csr
            #NAME AGE SIGNERNAME REQUESTOR CONDITION
            #node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A 6m3s kubernetes.io/kube-apiserver-client-kubelet kubelet-bootstrap Pending



        #11.批准申请
        kubectl certificate approve node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ-- K6M4G7bjhk8A



        #12.查看节点
            #由于网络插件还没有部署，节点会没有准备就绪 NotReady
            kubectl get node



        #13.部署 kube-proxy创建配置文件
            cat > /opt/kubernetes/cfg/kube-proxy.conf << EOF
            KUBE_PROXY_OPTS="--logtostderr=false \\
            --v=2 \\
            --log-dir=/opt/kubernetes/logs \\
            --config=/opt/kubernetes/cfg/kube-proxy-config.yml"
            EOF



        #14.配置参数文件
        cat > /opt/kubernetes/cfg/kube-proxy-config.yml << EOF
        kind: KubeProxyConfiguration
        apiVersion: kubeproxy.config.k8s.io/v1alpha1
        bindAddress: 0.0.0.0
        metricsBindAddress: 0.0.0.0:10249
        clientConnection:
           kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfig
        hostnameOverride: k8s-master
        clusterCIDR: 10.0.0.0/24
        EOF



        #15.生成 kube-proxy.kubeconfig 文件
            #生成 kube-proxy 证书
            # 切换工作目录 cd TLS/k8s # 创建证书请求文件
            cat > kube-proxy-csr.json<< EOF { "CN": "system:kube-proxy", "hosts": [],
"key": { "algo": "rsa", "size": 2048 },"names": [ { "C": "CN", "L": "BeiJing", "ST": "BeiJing", "O": "k8s", "OU": "System" } ] }EOF



        #16.生成证书
            cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json - profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy

            #ls kube-proxy*pem
            #kube-proxy-key.pem kube-proxy.pem



        #17.生成 kubeconfig 文件
            KUBE_APISERVER="https://192.168.31.71:6443"

            kubectl config set-cluster kubernetes \
            --certificate-authority=/opt/kubernetes/ssl/ca.pem \
            --embed-certs=true \
            --server=${KUBE_APISERVER} \
            --kubeconfig=kube-proxy.kubeconfig kubectl config set-credentials kube-proxy \
            --client-certificate=./kube-proxy.pem \
            --client-key=./kube-proxy-key.pem \
            --embed-certs=true \
            --kubeconfig=kube-proxy.kubeconfig

            kubectl config set-context default \
            --cluster=kubernetes \
            --user=kube-proxy \
            --kubeconfig=kube-proxy.kubeconfig

            kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig


        #18.拷贝到配置文件指定路径
            cp kube-proxy.kubeconfig /opt/kubernetes/cfg/



        #19.systemd 管理 kube-proxy
            cat > /usr/lib/systemd/system/kube-proxy.service << EOF
            [Unit]
            Description=Kubernetes Proxy
            After=network.target
            [Service]
            EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf
            ExecStart=/opt/kubernetes/bin/kube-proxy \$KUBE_PROXY_OPTS
            Restart=on-failure
            LimitNOFILE=65536
            [Install]
            WantedBy=multi-user.target
            EOF



        #20.启动并设置开机启动
            systemctl daemon-reload
            systemctl start kube-proxy
            systemctl enable kube-proxy




        #21.部署 CNI 网络
            #先准备好 CNI 二进制文件
            #下载地址： https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni- plugins-linux-amd64-v0.8.6.tgz

            #解压二进制包并移动到默认工作目录
            mkdir /opt/cni/bin
            tar zxvf cni-plugins-linux-amd64-v0.8.6.tgz -C /opt/cni/bin



        #22.部署 CNI 网络
        wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
        sed -i -r "s#quay.io/coreos/flannel:.*-amd64#lizhenliang/flannel:v0.12.0- amd64#g" kube-flannel.yml
        #默认镜像地址无法访问，修改为 docker hub 镜像仓库
        kubectl apply -f kube-flannel.yml
        kubectl get pods -n kube-system
        kubectl get node
        #部署好网络插件，Node 准备就绪


        #23.授权 apiserver 访问 kubelet
            cat > apiserver-to-kubelet-rbac.yaml<< EOF
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
               annotations: rbac.authorization.kubernetes.io/autoupdate: "true"
               labels: kubernetes.io/bootstrapping: rbac-defaults name:
               system:kube-apiserver-to-kubelet rules: - apiGroups: - ""
               resources: - nodes/proxy - nodes/stats - nodes/log - nodes/spec - nodes/metrics - pods/log verbs: - "*" ---
               apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding
               metadata: name: system:kube-apiserver namespace: "" roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:kube-apiserver-to-kubelet subjects:
            - apiGroup: rbac.authorization.k8s.io kind: User name: kubernetes
            EOF
            kubectl apply -f apiserver-to-kubelet-rbac.yaml




        #24.新增加 Worker Node
        #拷贝已部署好的 Node 相关文件到新节点
        #在 master 节点将 Worker Node 涉及文件拷贝到新节点 192.168.31.72/73
        scp -r /opt/kubernetes root@192.168.31.72:/opt/
        scp -r /usr/lib/systemd/system/{kubelet,kube-proxy}.service root@192.168.31.72:/usr/lib/systemd/system
        scp -r /opt/cni/ root@192.168.31.72:/opt/
        scp /opt/kubernetes/ssl/ca.pem root@192.168.31.72:/opt/kubernetes/ssl



        #25.删除 kubelet 证书和 kubeconfig 文件
        rm /opt/kubernetes/cfg/kubelet.kubeconfig
        rm -f /opt/kubernetes/ssl/kubelet*
        #注：这几个文件是证书申请审批后自动生成的，每个 Node 不同，必须删除重新生成。


        #26. 修改主机名
        vi /opt/kubernetes/cfg/kubelet.conf
        --hostname-override=k8s-node1
        vi /opt/kubernetes/cfg/kube-proxy-config.yml
        hostnameOverride: k8s-node1



        #27.启动并设置开机启动
        systemctl daemon-reload
        systemctl start kubelet
        systemctl enable kubelet
        systemctl start kube-proxy
        systemctl enable kube-proxy



        #28.在Master上批准新Node kubelet证书申请
        $kubectl get csr
        #NAME AGE SIGNERNAME REQUESTOR CONDITION
        #node-csr-4zTjsaVSrhuyhIGqsefxzVoZDCNKei-aE2jyTP81Uro 89s kubernetes.io/kube-apiserver-client-kubelet kubelet-bootstrap Pending
        $kubectl certificate approve node-csr-4zTjsaVSrhuyhIGqsefxzVoZDCNKei- aE2jyTP81Uro


        #29.查看Node状态
        Kubectl get node
        #Node2（192.168.31.73 ）节点同上。记得修改主机名！


```
