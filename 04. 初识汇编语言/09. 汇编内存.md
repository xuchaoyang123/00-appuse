## 汇编的内存



```shell
    -寄存器很小,不够用,所以说,数据放到内存里.
    -每个应用程序都有4G的内存空间.空头支票

```

### 1. 探究 每个应用程序都有4G的内存空间?
```shell
    #程序真正运行的时候,才会用到物理内存.

    1B   =8 bit
    1KB  =1024B
    1MB  =1024KB
    1GB  =1024MB

    4G的内存, 4096m===> 最终计算为位,就是这个可以存储的最大容量。
    计算机内存地址很多,空间很大.

  
```

### 2. 内存地址

```shell
    -存一个数: 占用的大小,数据宽度,存在哪里都有了.
    -计算机中内地址很多,每个空间分配一个地址,名字.
    -给这些内存起的编号,就是我们的内存地址: 32位 8个16进制的值

     0000 0000   ---->  0x00000000
     0000 0001   ---->  0x00000001
     0000 0010   ---->  0x00000010
     .....       ---->  0xFFFFFFFF
       
    32位: 寻址能力 4GB
    FFFFFFFF+1 = 100000000 最大值

    位是怎么限制内存大小的.
    100000000*8 = 位: 800000000


```


```shell

#推算过程：
   

    FFFF FFFF +1 = 100000000           #能存最大位数. 
    100000000 * 8 = 800000000          #一个值里能存8位,所以要*8
    800000000  = 34,359,738,368        #转换成十进制
    34,359,738,368 /8 =4,294,967,296   #除8变成字节.
    4,294,967,296/1024/1024/1024 = 4G   #4G


#每个内存地址都有一个编号,可以通过这些编号里面存值.
#不是任意的地址都可以写入的,需要申请使用,只有程序申请过的内存才可以使用.

    -要有数据宽度： 不能随便给个1,要知道存在多少位里面. 数据宽度: byte word dword
    -地址的位置:  例如: 0XFFFFFFFF


    
```

### 3. 内存如何存值

```shell

举例:

    #byte 类型写入
    0019FF70|0019FF80             #堆栈信息框:内存地址 数值 原值
    mov byte ptr ds:[0019FF70],1  #给0019FF70地址修改数据
    0019FF70|0019FF01             #结果,只修改了最后的数字01

    #dword写入
    0019FF74|74D36359             # #堆栈信息框:内存地址 数值 原值
    mov dword ptr ds:[0019FF74],1 
    0019FF74|00000001             #结果整体修改了.  
```


```shell
#内存地址有多重写法.
     ds:[0019FF70+4]        #给地址增加偏移,70+4=74
     ds:[eax]               #把寄存器里的数值放到内存里.
     ds:[eax+4]             #寄存器偏移.

#数组实现:[]

    ds:[reg+reg*{1,2,4,8}]    #reg代表寄存器的意思, 寄存器乘值
     ds:[reg+reg*{1,2,4,8}+4] #reg代表寄存器的意思, 寄存器乘值然后在加偏移

```